These directories contain gzipped RLP-encoded blockchain data files along with respective JSON configuration files.

The blockchains contained in these data files use configurations that are designed to reflect the stages of their namesake production counterparts, eg. Ethereum Classic and Foundation main networks, albeit in smaller "condensed" versions.
Whereas the prominent test networks used in staging and development for these communities often (in the case of Goerli, Kotti, Mordor, Ropsten, and Rinkeby) use abbreviated fork configurations,
where mainnet forks prior to the launch of the given testnet are "squashed" into the testnet's configuration at block 0, and thus never actually transitioned through at any point in the testnets' progress.

This testnet/mainnet configuration discrepency is in principle a cause of concern since:
- configuration can be expected to be a probably root source of bugs (see Dan Luu's excellent writings),
- chain fork progressions are meaningful things in their own right (eg. `eth/64`, the `forkid` protocol),
- protocol provider support for historic chain configurations will be an eternal necessity, since the data is, essentially, canonical and immutable.

The test blockchains included in these directories were generated as follows:
- Design the configuration to reflect the fork progression of the respective main network. Forks are not squashed, the DAO fork is activated, and forks that happened simultaneously on mainnets happen likewise simultaneously in the test configs. As a general guide, mainnet fork activations numbers were simply divided by 1000.
- Initialize the test blockchain with the given config.
- Run an adhoc tool based on the `tests/#TestState` program, which is originally used to run the tests of `ethereum/tests`. These tests are intended to be cross-client state tests. They are programmatically generated, and are intended to test the EVM and associated state behavior of clients in the context of gas reprices and modified state behaviors. My adhoc tool built on top of them hijacks the test runner and instead of running the tests in their normal artificial Go test environmnent, the state tests are instead applied to the running blockchain by transforming them into series of transactions. "Pre" states, when necessary, are established by sending contract-create transactions; subsequent transactions depending on the pre-states are held in memory and an RPC subscription to the `new head` method of the running client is used to parse new chain heads and associate pending transactions to their respective transaction receipts generated by the pre-state contract creation. Once the desired receipt is found on chain, the following dependent transaction may be made against that contract address.

State tests are grouped by fork, with names like "Homestead" and "Byzantium". The adhoc tool applies tests for "Homestead" only during the relative "Homestead"-equivalent phase of the test blockchain. In order to fit tests in to these respective phases of the test blockchains, some "wiggling" with these fork activations were necessary. That's why for the most part the respective fork numbers are `mainnet/1000`, but a few are fudged up or down. This wiggling does not impact the integrity of the chain configurations as heuristics for the mainnet counterparts, since what matters most is chronology and relative activation.

In general, the integrity of the GeneralStateTests to blockchain transactions are not of critical concern, and they are more-or-less used as arbitrary simulated transactions. 

- Once all of the forks have been progressed through and all StateTests (`GeneralStateTests`) have completed being processed as transactions, the chain is stopped and `export`ed to the gzipped RLP file.
- This produced `export.rlp.gz` file can then, as a regression test, be `import`ed into a new database, and in doing so, cause geth to validate all available aspects of its chain configuration, feature application, and data storage mechanisms. At the time of writing, geth's `import` command uses `blockchain.InsertChain` to do the work of the import, which is the very same function used by geth during a networked sync. As such, `ValidateState`, `ValidateHeaders`, and `ValidateBody` are all invoked. This proves geth's consistency in EVM processing, state mutations, and header verification; all consensus-relevant values are tested.

A script to finally run these tests would be as follows:

```
> make geth
> ./build/bin/geth --datadir=./tmpdatadir init classic.conf.json
> ./build/bin/geth --datadir=./tmpdatadir import export.rlp.gz
> rm -rf ./tmpdatadir
```

Note that in the case of foundation-condense* tests, the ethereum/go-ethereum client should be able to successfully import these files as well... likewise any protocol provider programs that supports the configuration and the file encoding.
